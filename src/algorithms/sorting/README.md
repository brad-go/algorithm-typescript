# 정렬 (sort)

컴퓨터 분야에서 중요시되는 문제 가운데 하나로 **어떤 데이터들이 주어졌을 때, 이를 정해진 순서대로 나열하는 문제**입니다. 실제로 컴퓨터 분야에서 사용하는 데이터의 경우 숫자의 순서나 어휘의 순서대로 정렬한 다음 사용해야 되는 경우가 자주 발생하는데, 이걸 **얼마나 효과적으로 해결할 수 있느냐**가 정렬 문제의 핵심입니다.

## 목차

1. [버블 정렬](./bubble-sort)
2. [선택 정렬](./selection-sort)
3. [삽입 정렬](./insertion-sort)
4. [병합 정렬](./merge-sort)
5. [힙 정렬](./heap-sort)
6. [퀵 정렬](./quick-sort)
7. [기수 정렬](./radix-sort)
8. [계수 정렬](./counting-sort)
9. [셸 정렬](./shell-sort)
10. [버킷 정렬](./bucket-sort)

## 알아두어야 할 것들

### 시간 복잡도에 따른 알고리즘

#### O(n<sup>2</sup>)인 정렬 알고리즘

대개 계산 시간이 정렬할 자료의 수의 제곱에 비례헤서 늘어납니다. 즉, 1만 개를 1초에 정렬하면, 10만 개를 정렬하는 데에는 100초 정도가 필요합니다.

**대표적인 알고리즘: 버블 정렬, 선택 정렬, 삽입 정렬**

#### O(n log n)인 정렬 알고리즘

최선이나 평균적으로 O(n log n)의 성능을 가지는 알고리즘들입니다. 최악의 상황에서도 병합정렬이나 힙정렬은 O(n log n)을 유지하지만, 퀵 정렬은 오히려 O(n<sup>2</sup>)으로 뒤집니다. 하지만 실제로는 퀵정렬이 일반적으로 가장 빨라서 퀵정렬을 조금 개량해서 최악의 경우가 (거의) 발생하지 않도록 코드를 짜거나 나쁜 경우다 싶으면 힙정렬로 전환하게끔 코드를 짭니다. 이 알고리즘들은 서로만의 특유한 성질과 장단점이 있습니다.

**대표적인 알고리즘: 병합 정렬, 힙 정렬, 퀵 정렬**

#### 그 외

비교 정렬 알고리즘은 O(n log n) 이상의 속도를 낼 수 없다고 알려져 있습니다. 그러나 아래처럼 비교를 하지 않거나 특정 상황에서 더 빠른 O(n)에 가까운 속도로 정렬을 하는 알고리즘들이 있습니다.

**대표적인 알고리즘: 기수 정렬, 계수 정렬, 셸 정렬, 버킷 정렬**

### 안정성(Stability)

#### 안정 정렬(Stable Sort)

안정 정렬은 중복된 값을 입력 순서와 동일하게 정렬하는 정렬 알고리즘을 말합니다.

- 대표적으로 삽입 정렬, 병합 정렬, 버블 정렬이 있습니다.

#### 불안정 정렬(Unstable Sort)

불안정 정렬은 안정 정렬과 반대로 중복된 값이 입력된 순서와 동일하지 않게 정렬되는 알고리즘을 말합니다.

- 대표적으로 퀵 정렬, 선택 정렬, 계수 정렬이 있습니다.

#### Example

```js
const train = [
  { departure: '서울', time: '09:00' },
  { departure: '대전', time: '09:30' },
  { departure: '대구', time: '10:00' },
  { departure: '서울', time: '10:30' },
  { departure: '대구', time: '11:00' },
  { departure: '부산', time: '11:30' },
  { departure: '부산', time: '12:00' },
];
```

위와 같은 기차표들이 있다고 생각해봅시다. 위의 기차표들을 출발시간 기준이 아닌 출발지를 서울 -> 대전 -> 대구 -> 부산 기준으로 정렬한다고 했을때, 안정 정렬과 불안정 정렬의 차이를 느낄 수 있습니다.

```js
const customCompareFunction = (a, b) => {
  const D = { 서울: 0, 대전: 1, 대구: 2, 부산: 3 };

  if (D[a.departure] === D[b.departure]) return 0;

  return D[a.departure] < D[b.departure] ? -1 : 1;
};
```

비교 함수는 출발지를 비교하기 위해 다음과 같이 생성했습니다. 위와 같은 비교 함수를 통해 안정 정렬인 삽입 정렬과 불안정 정렬인 퀵 정렬로 정렬을 수행해보겠습니다.

```bash
삽입 정렬 결과 - 안정 정렬
[
  { departure: '서울', time: '09:00' },
  { departure: '서울', time: '10:30' },
  { departure: '대전', time: '09:30' },
  { departure: '대구', time: '10:00' },
  { departure: '대구', time: '11:00' },
  { departure: '부산', time: '11:30' },
  { departure: '부산', time: '12:00' },
]

퀵 정렬 결과 - 불안정 정렬
[
  { departure: '서울', time: '10:30' },
  { departure: '서울', time: '09:00' },
  { departure: '대전', time: '09:30' },
  { departure: '대구', time: '11:00' },
  { departure: '대구', time: '10:00' },
  { departure: '부산', time: '12:00' },
  { departure: '부산', time: '11:30' }
];
```

두 정렬 결과의 차이가 보이시나요? 기존에 시간 순으로 정렬되어있었기 때문에 이를 위에서 말한 지역 순으로 정렬한다고 할 때:

- **안정 정렬**: 중복된 값, 즉 같은 지역의 경우 더 빠른 시간 순서로 정렬이 됩니다.
- **불안정 정렬**: 같은 지역에서 더 빠른 시간 순서로 정렬되는 것이 아닌 무작위로 섞여서 정렬을 하기에 시간 순서로 정렬이된 입력 값의 형태가 지역별 정렬을 거치면서 유지되지 않게 됩니다.

결과적으로 안정 정렬은 정렬 전과 후에도 중복된 값을 입력의 순서와 동일하게 유지하지만, 불안정 정렬은 그렇지 않다는 것을 알 수 있습니다.

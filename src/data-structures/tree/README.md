# 트리 (Tree)

**트리**는 **노드들이 나뭇가지처럼 연결된 비선형 계층적 자료구조**로 **부모 노드 밑에 여러 자식 노드가 연결되고, 자식 노드 각각에 다시 자식 노드가 연결**되는 **재귀적 형태의 자료구조**입니다. 단, 자식 노드의 자식이 부모로 연결되는 경우는 보통 트리로 인정하지 않습니다.
트리는 몇가지 기본적이며 재미있는 성질을 가지고 있는데, 트리구조에서 어떤 노드를 빼 버리면 그로 인해 새로 생성되는 연결되지 않은 트리의 개수는 해당 노드에 연결된 에지(edge)의 개수와 같습니다.

자식 노드에서 부모 쪽으로 계속해서 타고 올라가다 보면 결국 부모가 없는 하나의 노드로 이어지는데, 이 노드를 **루트 노드(root node)** 라고 부릅니다. 이 루트 노드를 중심으로 뻗어나가는 모습의 나무의 구조와 비슷하다 하여 '트리(tree)'라는 이름이 붙었고, '수형도'라고 부르기도 합니다.

- 사이클이 없는 연결 그래프
- **방향성이 있는 비순환 그래프(DAG)** 의 한 종류

## 트리 관련 용어

![트리 용어](https://images.velog.io/images/root1031/post/886cfefd-3378-467b-8153-4a0eeddaa086/image.png)

- **노드(node)**: 트리를 구성하는 기본 원소
  - **루트 노드(root node / root)**: 트리에서 부모가 없는 최상위 노드, 트리의 시작점
  - **부모 노드(parent node)**: 루트 노드 방향으로 직접 연결된 노드
  - **자식 노드(child node)**: 루트 노드 반대 방향으로 직접 연결된 노드
  - **형제 노드(siblings node)**: 같은 부모 노드를 갖는 노드들
  - **리프 토드(leaf node / leaf)**: 루트 노드를 제외한 차수가 1인 정점. 쉽게 말해 자식이 없는 노드로 단말 노드라 부르기도 합니다.
- **경로(path)**: 한 노드에서 다른 한 노드에 이르는 길 사이에 잇는 노드들의 순서
- **길이(length)**: 출발 노드에서 도착 노드까지 거치는 간선의 개수
- **깊이(depth)**: 루트 노드에서 현재 노드까지의 거리
- **레벨(level)**: 루트 노드(level = 0)부터 노드까지 연결된 간선 수의 합
- **높이(height)**: 가장 긴 루트 경로의 길이
- **차수(degree)**: 각 노드의 자식의 개수
- **트리의 차수(degree of tree)**: 트리의 최대 차수 = max[deg1, deg2, ..., degn]
- **크기(size)**: 노드의 개수
- **너비(width)**: 가장 많은 노드를 갖고 있는 레벨의 크기
- **내부 정점(internal vertex)**: 차수가 2 이상인 정점
- **포레스트(forest)**: 서로 독립인 트리들의 모임
- **방향 트리(directed tree)**: 방향을 무시하고 생각했을 때 트리인 유향 그래프는 방향 트리입니다. 자료구조의 트리는 방향 트리의 일종입니다.

## 트리의 특징

- 트리는 항상 **단방향**입니다.
- 트리는 사이클이 존재할 수 없습니다.
- 그래프의 한 종류로 **최소 연결 트리**라고도 불립니다.
- 노드가 N개인 트리는 항상 N-1개의 간선(edge)를 가집니다.
- 임의의 두 노드(정점)간의 경로는 유일합니다.
- 한 개의 루트 노드만이 존재하며, 모든 자식 노드는 한 개의 부모 노드만을 가집니다.
- 순회는 pre-order, in-order, post-order 세가지 방식으로 이루어집니다.
- 트리는 이진 트리, 이지 탐색 트리, 균형 트리(AVL 트리, red-black 트리), 이진 힙(최대 힙, 최소 힙) 등이 있습니다.

## 이진 트리 (Binary Tree)

![이진 트리](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/1920px-Binary_search_tree.svg.png)

부모 노드 밑의 자식 노드 개수(=차수, degree)를 최대 2개로 제한하는, 트리의 가장 간단한 형태. 두 자식 노드를 보통 왼쪽 자식과 오른쪽 자식으로 구분지으며, 하나의 값과 오른쪽 자식 노드를 가리킬 두 개의 포인터를 가진 구조로 구현할 수 있습니다.

일반적으로 n개의 자식을 가질 수 있는 트리 구조에서, 1개를 초과한 자식 하나마다 노드를 하나 추가해 추가된 새 노드의 왼쪽에 원래의 자식 노드, 오른쪽에 형제 노드를 배치하는 이진 트리 구조로 변환할 수 있으며(Left-Child, Right-Sibling), 이 방법으로 모든 트리를 이진 트리 형태로 재구성할 수 있습니다. 때문에 일반적으로 트리는 이진 트리로 구현됩니다.

### 이진 트리의 종류

![이진 트리의 종류](https://gmlwjd9405.github.io/images/data-structure-tree/tree-types-example.png)

#### 정 이진 트리 (Full Binary Tree or Strictly Binary Tree)

![정 이진 트리](https://gmlwjd9405.github.io/images/data-structure-tree/Full-Binary-Tree.png)

- 모든 노드의 자식 노드가 0개나 2개인 트리

#### 완전 이진 트리 (Complete Binary Tree)

![완전 이진 트리](https://gmlwjd9405.github.io/images/data-structure-tree/Complete-Binary-Tree.png)

- 모든 리프 노드의 높이가 최대 1차이가 나고, 모든 노드의 오른쪽 자식이 있으면 왼쪽 자식이 있는 이진 트리
- 트리의 요소를 왼쪽에서 오른쪽으로 하나씩 빠짐없이 채워나간 형태
- 포화 이진 트리는 완전 이진 트리의 부분집합입니다.
- 단, 포화 이진 트리가 아닌 완전 이진 트리는 정 이진 트리일 수도 있고, 아닐 수도 있습니다.
- 완전 이진 트리의 개념은 힙(heap)과 관련이 있습니다.
- 배열을 사용해 효율적인 표현이 가능합니다.

#### 포화 이진 트리 (Perfect Binary Tree)

![포화 이진 트리](https://gmlwjd9405.github.io/images/data-structure-tree/Perfect-Binary-Tree.png)

- 모든 리프 노드의 높이가 같고, 리프 노드가 아닌 노드는 모두 2개의 자식을 갖습니다.
- 이진 트리에서 리프 높이의 최대치가 n일 때 가장 많이 존재할 수 있는 노드의 수는 `2^n-1`개인데, 포화 이진 트리는 이 개수를 모두 채운 이진 트리라고도 볼 수 있습니다.
- 모든 포화 이진 트리는 정 이진 트리입니다.
- 정 이진 트리이면서 완전 이진 트리인 경우

### 이진 트리의 순회 방법

- **중위 순회(In-order traversal)**: 왼쪽 자손, 자신, 오른쪽 자손 순서로 방문하는 순회 방법. 이진 탐색 트리를 **중위 순회하면 정렬된 결과**를 얻을 수 있다.
- **전위 순회(Pre-order traversal)**: 자신, 왼쪽 자손, 오른쪽 자손 순서로 방문하는 순회 방법
- **후위 순회(Post-order traversal):** 왼쪽 자손, 오른쪽 자손, 자신 순서로 순회하는 방법
- **레벨 순서 순회(Level-order traversal)**: 너비 우선 순회(Breadth-First traversal)라고도 하며, 노드를 레벨 순서로 방문하는 순회 방법입니다. 위 세가지는 [스택](../stack/)을 활용하여 구현할 수 있는 반면 레벨 순서 순회는 [큐](../queue/)를 활용해 구현할 수 있습니다.

![트리 순회](https://gseok.gitbooks.io/algorithm/content/assets/2-search-tree.png)

위의 트리를 순회하면 다음과 같은 결과를 얻습니다.

- In-order: 1 3 4 6 7 8 10 13 14
- Pre-order: 8 3 1 6 4 7 10 14 13
- Post-order: 1 4 7 6 3 13 14 10 8
- Level-order: 8 3 10 1 6 14 4 7 13

## 트리의 장점

- 계층형 데이터 저장에 용이합니다.
- 동적인 크기를 가집니다.
- 빠른 삽입/삭제 작업
- 이진 트리에서 삽입된 노드는 즉시 정렬됩니다.

## 트리의 단점

- 노드들을 재배열 시 느립니다.
- 하위 노드는 상위 노드의 정보를 가지고 있지 않습니다.
- 이진 트리는 해시 테이블보다 느립니다.
- 이진 트리가 균현잡힌 하위 트리를 가지고 있지 않다면, 선형 탐색과 다를게 없습니다.

## 트리의 활용

- 계층적 데이터 저장
  - 윈도우/유닉스의 디렉터리(폴더) 구조
- 효율적인 삽입, 삭제 및 검색을 위해 트리 구조 활용
- 힙
- 데이터 베이스 인덱싱(B-Tree, B+Tree, AVL-Tree 등)
- Trie(사전 저장시 사용되는 특별한 종류의 트리)

## 참고

- [나무위키](<https://namu.wiki/w/%ED%8A%B8%EB%A6%AC(%EA%B7%B8%EB%9E%98%ED%94%84)>)
- [heejeong Kwon](https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html)

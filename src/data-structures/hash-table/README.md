# 해시 테이블 (Hash Table)

![해시 테이블 구조](https://blog.kakaocdn.net/dn/b1zOw1/btqL6HAW7jy/jpBA5pPkQFnfiZcPLakg00/img.png)

해시테이블이란 **검색하고자 하는 키 값을 입력받아서 해시 함수를 통해 반환받은 해시 코드를 배열의 인덱스로 변환해서 데이터에 접근하는 방식**의 자료구조입니다. 사용하는 키 값은 문자열이 될 수 있고, 숫자나 파일 데이터가 될 수도 있습니다.

- 키(key)와 값(value)이 하나의 쌍을 이루는 데이터 구조
- 키와 배열의 인덱스를 이용하여 값을 저장하는 자료구조
- 해시 테이블은 해시 함수를 사용해 원하는 값을 담을 수 있는 버킷(bucket) 또는 슬롯(slot)의 배열로 인덱스를 계산합니다.

## 해시 (Hash)

**다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑(mapping)한 값**

## 해시 함수 (Hash Function)

**데이터를 효율적으로 관리하기 위해서 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수**

- 키를 해시 함수로 계산하여 그 값을 배열의 인덱스로 사용합니다.
- 입력값이 얼마나 큰지 상관없이 동일한 길이의 해시코드를 생성해줍니다.
- 암호화폐의 핵심 기술인 블록체인에서도 해시 코드를 이용한다고 합니다.
- 이 해시 함수는 입력 데이터가 완전히 일치해야만 동일한 해시 코드를 반환해줍니다.

## 해시 충돌 (Hash Collision)

해시 테이블에서는 필수적으로 **해시 충돌(collision)** 이란 개념을 알아야 합니다. 이 충돌은 해시 테이블이 일정 크기의 배열을 정해두고 만들어두고 그 안에 데이터를 집어 넣기 때문에 해시 함수를 통해 입력받은 키 값을 해시 코드로 변환했을 때, 동일한 해시 코드 값을 가지는 문제가 발생할 수 있는데, 이를 해시 충돌이라고 합니다.
충돌이 일어나는 이유는 키 값은 문자열이고 가짓수가 무한한데 반해 해시 코드는 정수 개만큼만 생성할 수 있기 때문입니다. 그러므로 해시 알고리즘이 아무리 좋아도 어떤 키들은 중복되는 코드를 가질 수 밖에 없습니다.
때로는 해시 알고리즘이 서로 다른 해시 코드를 만들어 냈는데, 배열의 길이가 한정되어 있어서 같은 인덱스에 배정받을 수도 있기 때문에 충돌이 일어나게 됩니다.
위의 경우들 모두 충돌(collision)이라고 부르는데, 이 충돌을 최소화하기 위해서 좋은 해시 알고리즘을 짜는 것은 해시 테이블에서 정말 중요한 이슈입니다.

해시 테이블의 충돌을 해결할 수 있는 여러가지 방법을 알아보겠습니다.

### 개방 주소법 (Open Addressing)

개방 주소법은 해시 충돌이 발생하면 테이블 내의 새로운 주소를 탐사(probe)한 후, 비어있는 곳에 충돌된 데이터를 입력하는 방식입니다. 해시 함수를 거쳐서 나온 인덱스에 데이터가 이미 있으니, 다른 인덱스에 데이터를 저장한다는 의미로 **개방 주소(Open Address)** 라고 합니다.

개방 주소법은 어떤 방식으로 공간을 탐사할 것이냐에 따라 또 나뉘어지는데, 아래와 같이 세가지 방법이 있습니다.

#### 선형 탐사법 (Linear Probing)

선형 탐사법은 선형으로 순차적으로 탐사하는 방법입니다. 예시를 보겠습니다.

```js
const hashFunction = (key) => {
  return key % 10;
};

console.log(hashFunction(101)); // 1
console.log(hashFunction(1)); // 1
```

위와 같이 같은 해시값을 얻었을 경우 충돌이 발생하는데, **선형 탐사법은 이렇게 충돌이 났을 때, 정해진 칸만큼의 옆 버킷에 저장하는 방법**입니다.

| 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| --- | --- | --- | --- | --- | --- | --- |
|     | 101 | 11  |     |     |     |     |

만약 해시 함수에 key 값을 넣었을 대, 또 1이 나온다면, 충돌이 다시 발생합니다. 이번에는 3번 인덱스에 저장합니다. 이런 식으로 빈 공간이 나타날 때까지 순차적으로 탐사를 진행합니다.

| 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| --- | --- | --- | --- | --- | --- | --- |
|     | 101 | 11  | 21  | 31  |     |     |

**선형 탐사법은 특정 해시 값의 주변이 모두 채워져 있는 일차 군집화(Primary Clustering) 문제에 취약하다는 단점**이 있습니다.

같은 해시가 여러 번 나오는 상황에서 선형 탐사법을 사용하면 데이터가 연속되게 저장될 가능성이 높아집니다. 이런 경우 해시의 값이 1이 아니라 2나 3이 나왔을 때도 충돌이 발생합니다. 이미 해시 값으로 2, 3에 해당하는 곳에 데이터가 저장되어있기 때문입니다.

이런식으로 충돌이 계속될수록 데이터가 연속되게 저장되기 때문에 데이터 덩어리가 더 커져서 **데이터들의 특정 위치에만 밀집되는 현상**이 발생하는데, 이것을 **일차 군집화(Primary Clustering)** 이라고 합니다.

#### 제곱 탐사법 (Quadratic Probing)

**제곱 탐사법은 폭이 고정폭이 아닌 제곱으로 늘어나는 부분에서 선형 탐사법과 차이**를 가집니다.

1차 충돌 시 충돌 지점으로 부터 1의 제곱만큼, 2차 충돌 시 2의 제곱, 3차 충돌 시 3의 제곱만큼 탐사하는 스텝이 빠르게 커집니다. 선형 탐사법 때와 동일한 상황에서 제곱 탐사법은 해시 테이블은 아래와 같은 모양이 됩니다.

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|     | 101 | 11  |     |     | 21  |     |     |     |     | 31  |

이렇게 제곱 탐사법을 사용하면 충돌이 발생하더라도 데이터의 밀집도가 선형 탐사법보다 많이 낮기 때문에 다른 해시값까지 영향을 받아서 연쇄적으로 충돌이 발생할 확률이 많이 줄어듭니다.

그래도 결국 해시로 1이 여러 번 나오면 계속 충돌이 나는 것은 피할 수 없습니다. 결국 테이터의 군집은 피할 수 없는 숙명입니다. **처음 시작 해시값이 같을 경우, 그 이후의 해시 값들도 모두 동일한 값으로 계산되어 충돌이 반복적으로 일어나는 이 현상**을 **이차 군집화(Secondary Clustering)**이라고 부릅니다.

#### 이중 해싱 (Double Hashing)

이중 해싱은 **해시 함수를 이중으로 사용하는 것**을 뜻합니다.

**하나는 최초 해시를 얻을 때 사용하고, 다른 하나는 충돌이 났을 경우 탐사 이동폭을 얻기 위해 사용**합니다. 이렇게 하면, 최초 해시로 같은 값이 나오더라도 다른 해시 함수를 거치면서 다른 탐사 이동폭을 제공하기 때문에 다른 공간에 값이 골고루 저장될 확률도 높아집니다.

### 분리 연결법 (Seperate Chaining)

**해시 테이블의 버킷에 하나의 값이 아니라 링크드 리스트나 트리를 사용하는 방법**입니다.

체이닝이란 이름에서 유추할 수 있듯이 데이터들을 포인터를 이용해서 서로 체인 형태로 엮어 나가는 것을 뜻하며, 해시 테이블에선 동일한 해시값이 출력되어 충돌이 일어나면, 그 위치에 있던 데이터에 key값을 포인터로 뒤이어 연결해주는 방식입니다.

따라서 최초 위치에 저장된 데이터를 시작으로 그 이후의 값이 출력되는 데이터는 모두 연결 리스트의 형태를 취합니다. 그렇기 때문에 최초의 위치를 탐색하는 해시 과정을 제외하고, 모든 탐색, 삽인, 삭제 과정은 연결 리스트와 유사한 방식으로 진행하게 됩니다.

### 개방 주소법 vs 분리 연결법

#### 개방 주소법

- 분리 연결법과 달리 포인터가 필요 없고, 지정한 메모리 외에 추가적인 공간이 필요없습니다.
- 삽입, 삭제 시 오버헤드가 적습니다.

- 최악의 경우 비어잇는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있습니다.
- 특정 위치에만 데이터가 몰리는 군집화 현상이 나타날 수 있습니다.

#### 분리 연결법

- 삽입 또는 삭제가 간단합니다.
- 작은 데이터들을 저장할 때, 연결 리스트 자체의 오버헤드가 부담이 됩니다.

## 해시 테이블의 장점

- 검색, 삽입, 삭제 속도가 매우 빠릅니다. 해시 코드 자체가 나머지 연산을 통해 배열의 인덱스로 사용되기 때문에 검색이 필요없이 해시 코드로 데이터에 접근할 수 있기 때문입니다.
- 적은 리소스로 많은 데이터를 효율적으로 관리할 수 있습니다.

## 해시 테이블의 단점

- 해시 충돌
- 공간 복잡도가 커집니다.
- 순서가 있는 배열에는 어울리지 않습니다.
- 해시 함수 의존도가 높습니다.

## 해시 테이블의 활용

- 키(key)와 해시값(hash)이 연관성이 없어 보안에 사용됩니다.
- 데이터 캐싱(data caching)에 사용됩니다.

## 해시 테이블의 복잡도

### 시간 복잡도

|      | 삽입 | 접근 | 탐색 | 변경 | 삭제 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 평균 | O(1) | O(n) | O(1) | O(1) | O(1) |
| 최악 | O(n) | O(n) | O(n) | O(n) | O(n) |

### 공간 복잡도

- O(n)

## 해시 테이블 메서드 목록

### 삽입 및 삭제

- `set(key, value)`: 해시 테이블에 키-값쌍을 추가, 혹은 원래 키가 존재하면 값을 업데이트

### 접근

- `get(key)`: 키에 연결된 value를 반환하고 키가 없다면 null 반환
- `kesy()`: 해시 테이블의 키들을 담은 배열 반환
- `values()`: 해시 테이블의 값들을 담은 배열 반환
- `entries()`: 해시 테이블의 키-값 쌍들을 담은 배열 반환

### 탐색

- `containsKey(key)`: 해시 테이블이 키를 가지고 있다면 true, 아니면 false 반환
- `containsValue(value)`: 해시 테이블이 값을 가지고 있다면 true, 아니면 false 반환

### 삭제

- `delete(key)`: 입력받은 키를 가진 엔트리를 제거
- `clear()`: 해시 테이블 초기화

### 부가 기능

- `size()`: 리스트의 길이 반환
- `isEmpty()`: 리스트가 비었는지 boolean값 반환

## 참고

- [해쉬 알고리즘(Hash Algorithm) 요약 정리, 테스트 코드](https://hsp1116.tistory.com/35)
- [const_p님 블로그](https://overcome-the-limits.tistory.com/9)
